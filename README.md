# Ryan Stillings Cryptography and Network Security I - Homework Assignment 3  
## Dependencies:  
None  
## Writeup:  
The Blum Goldwasser Probabilistic Algorithm ended up making for a rather succinct implementation, thanks to considerable overlap between the encryption and decryption logic. The only library used for this assignment was math, which assisted with log calculations (numpy could have been used instead, but did not quite justify the introduction of an external dependency). Initially, I intended to perform the necessary calculations for the algorithm using binary ints and bitwise operators, but I ultimately found that I was more comfortable and confident in using Python's excellent string manipulation tools as in my previous works. The provided main file stores the message as a list of bits, runs it through encryption and then subsequent decryption, and finally prints out each of the results. The encryption itself can be broken down into two chunks; the first chunk calculates values for n,k,h, and t, while the second chunk breaks up m into m_i blocks and calculates ci for each block. A few lines use string splicing to emulate bitwise operations, and so their functionality is explained via comments in the code. The decryption operates similarly, with additional steps calculating x0 from the x_t+1 value generated during the encryption step.  

A few considerations were made in the completion of this assignment. For one thing, the random seed is squared a total of t+1 times in the encryption step, meaning the x value passed into the decryption step is xt+1. I believe it would still be correct if we only squared x a total of t times and passed xt to the decryption step instead, however that would result in different ciphertexts being generated from the ones that are currently produced. Another consideration is the primes p and q. In the case of this assignment, values for p and q were already provided to us, meaning we did not have to worry about generating blum primes. In a complete cryptosystem, however, to ensure proper security we would likely wish to generate blum primes on the Fly. In this case the work that we did for the makeup exam would be extremely useful, allowing us to use millerRobin and pollardRho to check for primality and factory into a prime, respectively.  
## Result:  
Calculated Ciphertext = 00100000110011100100  
Please see code for verification
